= GraphQL API
:slug: using-the-astra-graphql-api

Astra includes the Stargate GraphQL API to allow you to modify and query your table data using GraphQL.

The DataStax Astra GraphQL API allows you to easily interact with your data using GraphQL types, queries, and mutations.
For every <+++<glossary:table>+++> in your <+++<glossary:keyspace>+++>, a series of GraphQL objects are generated, along with queries and mutations that allow you to search and modify the table data.
[NOTE]
====
If you haven't already, create a <+++<glossary:database>+++> using <a href=\"https://astra.datastax.com/\" target=\"_blank\">DataStax Astra</a>.
====

We'll show you you how to:
. [Generate an authorization token](doc:generating-authorization-token)
. [Add rows to your table](doc:adding-rows-in-your-table-using-graphql)
. [Retrieve rows from your table](doc:retrieving-rows-in-your-table-using-graphql)
. [Update rows in your table](doc:updating-rows-in-your-table-using-graphql)
. [Delete rows in your table](doc:deleting-rows-in-your-table-using-graphql)

== About the GraphQL API endpoint
The Astra GraphQL API endpoint URL for your database is `https://\{databaseid}-\{region}.apps.astra.datastax.com/api/graphql`.
Each request must have a valid [authorization token](doc:generating-authorization-token) and a unique id.

[INFORMATION]
====
**Generating UUIDs**
Consider using a tool like this <a href=\"https://www.uuidgenerator.net/\" target=\"_blank\">online UUID generator</a> to quickly create a random UUID to pass with your requests if you are submitting the queries manually using a tool like cURL.
====

== Naming conventions for GraphQL
The default naming convention for the GraphQL API converts CQL table and <+++<glossary:column>+++> names to `lowerCamelCase` for GraphQL fields and `UpperCamelCase` for GraphQL types.
If the naming convention rules result in a naming conflict, a number suffix is appended to the name.
For example, if `someExistingColumn` already exists, the column will be named `someExistingColumn2` up to a maximum suffix value of 999.
If there are additional naming conflicts, an error will be occur.

== Mapping Astra tables to GraphQL fields and types
The Astra GraphQL API generates fields and types for each table in your database.
For example, for an Astra table named `products` the following fields and types are generated.
```
schema {
  query: Query
  mutation: Mutation
}

type Query {
  products(value: ProductsInput, orderBy: [ProductsOrder], options: QueryOptions): ProductsResult
  productsFilter(filter: ProductsFilterInput!, orderBy: [ProductsOrder], options: QueryOptions): ProductsResult
}

type Mutation {
  insertProducts(value: ProductsInput!, ifNotExists: Boolean, options: UpdateOptions): ProductsMutationResult
  updateProducts(value: ProductsInput!, ifExists: Boolean, ifCondition: ProductsFilterInput, options: UpdateOptions): ProductsMutationResult
  deleteProducts(value: ProductsInput!, ifExists: Boolean, ifCondition: ProductsFilterInput, options: UpdateOptions): ProductsMutationResult
}
```

=== Generated query types

The following query types are generated:
* `products()`: Query product values by equality.
If no value argument is provided then the first 100 (default pagesize) values are returned.
* `productsFilter`: Query products values by filtering the result with additional operators.
For example `gt` (greater than), `lt` (less than), `in` (in a list of values).
The `products()` equality style query is preferable if your queries don't require non-equality operators.

=== Generated mutation types

The following mutations are generated:
* `insertProducts()`: Insert a new product.
This is an "upsert" operation that will update the value of existing products if they already exists unless `ifNotExists` is set to true.
Using `ifNotExists` causes the mutation to use a lightweight transaction (LWT) adding significant overhead to the query.
* `updateProducts()`: Update an existing product.
This is also an "upsert" and will create a new product if one doesn't exists unless `ifExists` is set to true.
Using `ifExists` or `ifCondition` causes the mutation to use a lightweight transaction (LWT) adding significant overhead to the query.
* `deleteProducts()`: Deletes a product.
Using `ifExists` or `ifCondition` causes the mutation to use a lightweight transaction (LWT) adding significant overhead to the query.

As more tables are added to your keyspace additional fields will be added to the Query and Mutation types to handle queries and mutations for those new tables.
